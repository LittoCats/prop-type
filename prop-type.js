// Generated by CoffeeScript 1.12.7
(function() {
  var array, arrayOf, arrayOfType, bool, createChainableExtractor, createPrimitiveExtractor, isArray, isObject, match, number, object, onceOfType, oneOf, shape, string,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  isArray = function(value) {
    return Array.isArray(value);
  };

  isObject = function(value) {
    return !isArray(value) && typeof value === 'object';
  };

  createPrimitiveExtractor = function(PropType, isValid) {
    if (isValid === void 0) {
      isValid = function(value) {
        return typeof value === PropType;
      };
    }
    return function(isRequired, prop, value) {
      var error;
      if (!isRequired && value === void 0) {
        return void 0;
      }
      if (isValid(value)) {
        return value;
      }
      error = new Error("Expect typeof " + PropType + ", but received " + (typeof value));
      error.propPath = [prop];
      throw error;
    };
  };

  createChainableExtractor = function(original) {
    var optional, required;
    required = original.bind(null, true);
    optional = original.bind(null, false);
    required.optional = optional;
    required.required = required;
    optional.optional = optional;
    optional.required = required;
    return required;
  };

  exports.bool = bool = createChainableExtractor(createPrimitiveExtractor(typeof true));

  exports.string = string = createChainableExtractor(createPrimitiveExtractor(typeof ''));

  exports.number = number = createChainableExtractor(createPrimitiveExtractor(typeof 0));

  exports.object = object = createChainableExtractor(createPrimitiveExtractor('object', isObject));

  exports.array = array = createChainableExtractor(createPrimitiveExtractor('array', isArray));

  exports.oneOf = oneOf = function(validValues) {
    var extract;
    extract = function(isRequired, prop, value) {
      var error;
      if (!isRequired && value === void 0) {
        return void 0;
      }
      if (indexOf.call(validValues, value) >= 0) {
        return value;
      }
      error = new Error("expect oneOf [" + (validValues.join(', ')) + "], but recieved " + value);
      error.propPath = [prop];
      throw error;
    };
    return createChainableExtractor(extract);
  };

  exports.onceOfType = onceOfType = function(extractors) {
    var extract;
    extract = function(isRequired, prop, value) {
      var e, error, extractor, result;
      if (!isRequired && value === void 0) {
        return void 0;
      }
      for (extractor in extractors) {
        try {
          result = extractor(prop, value);
          error = void 0;
          break;
        } catch (error1) {
          e = error1;
          error = e;
          continue;
        }
      }
      if (error) {
        throw error;
      }
      return result;
    };
    return createChainableExtractor(extract);
  };

  exports.arrayOf = arrayOf = function(validValues) {
    var extract;
    if (!isArray(validValues)) {
      validValues = [];
    }
    extract = function(isRequired, prop, values) {
      var error, index, ref, value;
      if (!isRequired && values === void 0) {
        return void 0;
      }
      values = array.required(prop, values);
      for (index in values) {
        value = values[index];
        if (ref = !value, indexOf.call(validValues, ref) >= 0) {
          error = new Error("Expect one of [" + (validValues.join(', ')) + "], but recieved " + value);
          error.propPath = [prop, index];
          throw error;
        }
      }
      return values;
    };
    return createChainableExtractor(extract);
  };

  exports.arrayOfType = arrayOfType = function(extractor) {
    var extract;
    extract = function(isRequired, prop, values) {
      var error, index, results, value;
      if (!isRequired && values === void 0) {
        return void 0;
      }
      values = array.required(prop, values);
      try {
        results = [];
        for (index in values) {
          value = values[index];
          results.push(extractor.required(index, value));
        }
        return results;
      } catch (error1) {
        error = error1;
        if (!isArray(error.propPath)) {
          error.propPath = [];
        }
        error.propPath.unshift(prop);
        throw error;
      }
    };
    return createChainableExtractor(extract);
  };

  exports.shape = shape = function(definination) {
    var extract;
    extract = function(isRequired, prop, value) {
      var e, error, maybe, result;
      if (!isRequired && value === void 0) {
        return void 0;
      }
      result = {};
      try {
        for (prop in definination) {
          extract = definination[prop];
          maybe = extract(prop, value[prop]);
          if (maybe !== void 0) {
            result[prop] = maybe;
          }
        }
      } catch (error1) {
        e = error1;
        error = e;
      }
      if (error) {
        if (!Array.isArray(error.propPath)) {
          error.propPath = [];
        }
        error.propPath.unshift(prop);
        throw error;
      }
      return result;
    };
    return createChainableExtractor(extract);
  };

  exports.match = match = function(regex) {
    var extract;
    extract = function(isRequired, prop, value) {
      var error;
      if (!isRequired && value === void 0) {
        return void 0;
      }
      if (regex.test(value)) {
        return value;
      }
      error = new Error("Expect match " + regex + ", but received " + value);
      error.propPath = [prop];
      throw error;
    };
    return createChainableExtractor(extract);
  };

}).call(this);
